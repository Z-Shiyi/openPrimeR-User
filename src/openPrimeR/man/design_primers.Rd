% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimization_algo.R
\name{design_primers}
\alias{design_primers}
\title{Design of Multiplex PCR Primers.}
\usage{
design_primers(template.df, mode.directionality = c("both", "fw", "rev"),
  settings, init.algo = c("naive", "tree"), opti.algo = c("Greedy", "ILP"),
  required.cvg = 1, timeout = Inf, max.degen = 16, conservation = 1,
  sample.name = NULL, cur.results.loc = NULL, primer.df = NULL,
  updateProgress = NULL)
}
\arguments{
\item{template.df}{A \code{Templates} object containing the template
sequences and target regions for designing primers.}

\item{mode.directionality}{The template strand for which primers shall be designed.
Primers can be designed either for forward strands ("fw"), 
for reverse strands ("rev"), or for both strands ("both"). The default setting
is "both".}

\item{settings}{A \code{DesignSettings} object specifying the constraint settings for filtering and optimization.}

\item{init.algo}{The algorithm to be used for initializing primers.
If \code{init.algo} is "naive", then primers are constructed from substrings of the input template sequences.
If \code{init.algo} is "tree", phylogenetic trees are used to form degenerate primers whose degeneracy is bounded by \code{max.degen}.
This option requires an installation of MAFFT (see notes). The default \code{init.algo} is "naive".}

\item{opti.algo}{The algorithm to be used for solving the primer set covering problem. 
If \code{opti.algo} is "Greedy" a greedy algorithm is used to solve the 
set cover problem. If \code{opti.algo} is "ILP" an integer linear 
programming formulation is used. The default \code{opti.algo} is "Greedy".}

\item{required.cvg}{The desired ratio of of covered template sequences. 
If the target coverage ratio cannot be reached, the constraint settings
are relaxed according to the the constraint limits in order to reach the target coverage. 
The default \code{required.cvg} is set to 1, indicating that 100\% of the templates are to be covered.}

\item{timeout}{Timeout in seconds. Only applicable when \code{opti.algo} is "ILP".
The default is \code{Inf}, which does not limit the runtime.}

\item{max.degen}{The maximal degeneracy of primer candidates. This setting is particularly
relevant when \code{init.algo} is set to "tree". The default setting is \code{16}, which means
that at most 4 maximally degenerate positions are allowed per primer.}

\item{conservation}{Restrict the percentile of considered regions according to their conservation.
Only applicable for the tree-based primer initialization. At the its
default of 1, all available binding regions are considered.}

\item{sample.name}{An identifier for the primer design task. The default setting is
\code{NULL}, which means that the run identifier provided in \code{template.df} is used.}

\item{cur.results.loc}{Directory for storing the results of the primer design procedure.
The default setting is \code{NULL} such that no output is stored.}

\item{primer.df}{An optional \code{Primers} object. If an evaluated \code{primer.df} is provided,
the primer design procedure only optimizes \code{primer.df} and does not perform
the initialization and filtering steps. The default is \code{NULL} such that
primers are initialized and filtered from scratch.}

\item{updateProgress}{Shiny progress callback function. The default is \code{NULL}
such that no progress is logged.}
}
\value{
A list with the following fields:
\describe{
\item{\code{opti}:}{A \code{Primers} object providing the designed primer set.}
\item{\code{used_constraints}:}{A list with \code{DesignSettings} objects
for each primer direction providing the (possibly relaxed) constraints used
for designing the optimal primers.}
\item{\code{all_results}:}{A list containing objects of class \code{Primers}.
Each list entry corresponds to an optimal primer set for a given
melting temperature.}
\item{\code{all_used_constraints}:}{A list containing \code{DesignSettings} object for each optimized set in \code{all_results}.}
\item{\code{filtered}:}{A list with data providing information on the results
of the filtering procedure.}
}
}
\description{
Designs a primer set maximizing the number of covered templates using
the smallest possible number of primers. The algorithm tries to ensure
that the designed set of primers achieves a coverage ratio not lower than
\code{required.cvg}. To this end, the constraints for designing
primers may be relaxed.
}
\note{
Some constraints specified in the \code{settings} object
can only be computed if additional software is installed,
please see the documentation of \code{\link{DesignSettings}} for an overview of all possible settings and the \code{\link{ConstraintSettings}} documentation
for an overview of all possible constraints.
Usage of \code{init.algo = "tree"} requires an installation of
the multiple alignment program MAFFT (http://mafft.cbrc.jp/alignment/software/).
}
\section{{1. Initialization}}{

The primer design algorithm consists
of three steps: primer initialization, filtering, and optimization.
The method for initializing a set of candidate primers is determined
via \code{init.algo}. If \code{init.algo} is set to \emph{naive}, primers
are created by extracting substrings from all input template sequences.
If \code{init.algo} is set to \emph{tree}, degenerate primers are created by
merging similar subsequences by forming their consensus sequence up to
a degeneracy of at most \code{max.degen}. The tree-based initialization
is recommended for related sequences.
}

\section{{2. Filtering}}{

The candidate primer set is filtered according to the constraints
specified in the \code{settings} object. In some cases, it is necessary
to relax the constraints in order to reach the desired \code{required.cvg}.
In these cases, primers that fail the input constraints may be selected. 
If you would like to skip the initialization and filtering stages,
you can provide an evaluated \code{Primers} object via \code{primer.df}.
}

\section{{3. Optimization}}{

Optimizing a primer set entails finding the smallest subset of primers
maximizing the coverage, which is done by solving the set cover problem.
If melting temperature differences are a constraint,
the optimization procedure automatically samples ranges of melting
temperatures to find optimal sets for all possible temperatures.
You can select the used optimization algorithm via \code{optia.algo}, where
you can set "Greedy" for a greedy algorithm or "ILP for 
an integer linear program formulation (ILP).
While the worst-case runtime of the
greedy algorithm is shorter than the worst-case runtime of the ILP, 
the greedy solution may yield larger primer sets than the ILP solution.
}

\examples{
# Define PCR settings and primer criteria
data(Ippolito)
constraints(settings)$primer_length <- c("min" = 18, "max" = 18)
# Design only forward primers using a greedy algorithm
optimal.primers.greedy <- design_primers(template.df[1:2,], "fw", settings, init.algo = "naive")
# Design forward and reverse primers using an ILP and store 
# the results in 'out.dir'
out.dir <- tempdir()
optimal.primers.ILP <- design_primers(template.df[1:2,], "both", settings,
                         init.algo = "naive", opti.algo = "ILP",
                         cur.results.loc = out.dir)
# Usage of the tree-based initialization strategy (requires MAFFT)
\dontrun{
optimal.primers.tree <- design_primers(template.df[1:2,], "both", settings,
                         init.algo = "tree", opti.algo = "ILP",
                         max.degen = 16,
                         cur.results.loc = out.dir)
}
}
\seealso{
Other primer functions: \code{\link{Primers-class}},
  \code{\link{check_constraints}},
  \code{\link{check_restriction_sites}},
  \code{\link{create_report}},
  \code{\link{filter_primers}},
  \code{\link{get_initial_primers}},
  \code{\link{primer_significance}},
  \code{\link{score_degen}}, \code{\link{write_primers}}
}
\keyword{Primers}
